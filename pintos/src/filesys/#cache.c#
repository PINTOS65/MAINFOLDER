#include "filesys/cache.h"
#include "filesys/filesys.h"
#include "threads/palloc.h"
#include "threads/vaddr.h"
#include "threads/thread.h"
#include "lib/string.h"
#include "devices/timer.h"
#include <stdbool.h>

#define CACHE_SECTOR_CNT 64

struct cte
{
  block_sector_t sector;
  int accessed_cnt;
  int dirty_cnt;
  bool in_use;
};

static void* cache;
static struct cte ct[CACHE_SECTOR_CNT];
static struct semaphore cache_sema;
static int victim_idx;

static int cache_alloc (block_sector_t);
static void cache_flush_thread (void*);

void
cache_init (void)
{
  cache = palloc_get_multiple (PAL_ASSERT | PAL_ZERO, BLOCK_SECTOR_SIZE * CACHE_SECTOR_CNT / PGSIZE);
  for (int i = 0; i < CACHE_SECTOR_CNT; i++)
    ct[i].in_use = false;
  sema_init (&cache_sema, 1);
  victim_idx = 0;

  const char* name = "cache_flush_thread";
  thread_create (name, PRI_DEFAULT, cache_flush_thread, NULL);
}

void
cache_read (block_sector_t sector, void* buffer)
{
  cache_read_at (sector, buffer, BLOCK_SECTOR_SIZE, 0);
}

void
cache_read_at (block_sector_t sector, void* buffer, off_t size, off_t ofs)
{
  ASSERT (ofs + size <= BLOCK_SECTOR_SIZE);
  sema_down (&cache_sema);

  int i;
  for (i = 0; i < CACHE_SECTOR_CNT; i++)
  {
    if (ct[i].in_use && ct[i].sector == sector)
    {
      memcpy (buffer, cache + i * BLOCK_SECTOR_SIZE + ofs, size);
      ct[i].accessed_cnt++;
      break;
    }
  }

  if (i == CACHE_SECTOR_CNT)
  {
    int cache_idx = cache_alloc (sector);
    block_read (fs_device, sector, cache + cache_idx * BLOCK_SECTOR_SIZE);
    memcpy (buffer, cache + cache_idx * BLOCK_SECTOR_SIZE + ofs, size);
  }

  sema_up (&cache_sema);
}

void
cache_write (block_sector_t sector, const void* buffer)
{
  cache_write_at (sector, buffer, BLOCK_SECTOR_SIZE, 0);
}

void
cache_write_at (block_sector_t sector, const void* buffer, off_t size, off_t ofs)
{
  sema_down (&cache_sema);

  int i;
  for (i = 0; i < CACHE_SECTOR_CNT; i++)
  {
    if (ct[i].in_use && ct[i].sector == sector)
    {
      memcpy (cache + i * BLOCK_SECTOR_SIZE + ofs, buffer, size);
      ct[i].accessed_cnt++;
      ct[i].dirty_cnt++;
      break;
    }
  }

  if (i == CACHE_SECTOR_CNT)
  {
    int cache_idx = cache_alloc (sector);
    memcpy (cache + cache_idx * BLOCK_SECTOR_SIZE + ofs, buffer, size);
    ct[cache_idx].dirty_cnt++;
  }

  sema_up (&cache_sema);
}

static int
cache_alloc (block_sector_t sector)
{
  int result = 0;
  int i;

  for (i = 0; i < CACHE_SECTOR_CNT; i++)
  {
    if (ct[i].accessed_cnt < ct[result].accessed_cnt)
      result = i;

    if (!ct[i].in_use)
    {
      ct[i].sector = sector;
      ct[i].accessed_cnt = 0;
      ct[i].dirty_cnt = 0;
      ct[i].in_use = true;
      result = i;
      break;
    }
  }

  /* eviction */
  if (i == CACHE_SECTOR_CNT)
  {
    if (ct[result].dirty_cnt > 0)
      block_write (fs_device, ct[result].sector, cache + result * BLOCK_SECTOR_SIZE);

    ct[result].sector = sector;
    ct[result].accessed_cnt = 0;
    ct[result].dirty_cnt = 0;
    ct[result].in_use = true;
  }

  return result;
}

void
cache_flush (void)
{
  sema_down (&cache_sema);

  for (int i = 0; i < CACHE_SECTOR_CNT; i++)
  {
    if (ct[i].in_use && ct[i].dirty_cnt > 0)
    {
      block_write (fs_device, ct[i].sector, cache + i * BLOCK_SECTOR_SIZE);
      ct[i].in_use = false;
    }
  }

  sema_up (&cache_sema);
}

static void
cache_flush_thread (void* aux UNUSED)
{
  while (true)
  {
    timer_sleep (50);
    cache_flush ();
  }
}
